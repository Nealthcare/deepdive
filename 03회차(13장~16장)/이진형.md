## 13장

### 13.1 스코프란?

- 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 걸정됨
- 식별자 결정: 이름이 같은 (변수 등)이 여러개 있으면 어떤 변수를 참조해야할지 결정
- 식별자를 검색할때 사용하는 규칙

### 13.2 스코프의 종류

- 자신이 선언된 위치에 의해 스코프가 결정 (전역 / 지역)
- 전역은 어디서든 참조할 수 있음
- 지역은 자신의 지역과 하위 지역에서 유효

### 13.3 스코프 체인

- 함수 몸체 내부에서 함수를 정의하면 함수의 중첩
  - 중첩함수: 내부에서 정의한 함수
  - 외부함수: 중첩함수를 포함하는 함수
- 함수의 지역 스코프 또한 중첩될 수 있음
  - 스코프가 함수의 중첩에 의해 계층적 구조를 갖음
- 모든 지역 스코프의 최상위 스코프는 전역 스코프
- 변수를 참조할때 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프로 이동하며 검색함

### 13.4 함수 레벨 스코프

- 지역: 함수 몸체 내부 - 지역 스코프 생성
- `var` 키워드로 선언된 변수: 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성
  - if, for, while, try/catch 이런거는 영향받지 않음

### 13.5 렉시컬 스코프

```jsx
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

- bar 함수의 상위 스코프가 무엇인지에 따라 결정됨
  - 동적 스코프: 함수를 어디서 호출했는지에 따라서
  - **렉시컬 스코프: 함수를 어디서 정의했는지에 따라서 ← 짜스**
- 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정됨

## 14장 전역 변수의 문제점

### 14.1 변수의 생명 주기

- 변수는 자신이 선언된 위치에서 생성되고 소멸함
  - 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 동일함
  - 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸함
- 변수 호이스팅
  - 전역 변수: 런타임 이전 단계에서 엔진에 의해 먼저 실행됨
  - 지역 변수: 함수가 호출된 직후, 함수 몸체의 코드가 한 줄 씩 순차적으로 실행되기 이전에 엔진에 의해 먼저 실행됨
- 지역 변수가 함수보다 오래 생존하는 경우
  - 생명 주기: 메모리 공간에 할당된 시점부터 - 메모리 공간이 해제되어 메모리 풀에 반환되는 시점까지
  - 누군가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존할 수 있음
- 전역 변수의 생명 주기
  - 코드가 로드 되자마자 곧바로 해석되고 실행 / 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료
- 전역 객체
  - 브라우저 환경: window
  - 노드 환경: global

### 14.2 전역 변수의 문제점

- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용
- 생명주기가 길어 메모리를 오랜 기간 소비
- 스코프 체인상의 종점에 존재해 검색 속도가 가장 느림
- 네임스페이스 오염 (이름 겹쳐잉)

### 14.3 전역 변수의 사용 억제법

- 즉시 실행 함수로 감싸기
  - 정의와 동시에 실행 - 단 한번만 호출되므로 지역 변수화할 수 있음
- 네임스페이스 객체
  - 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가
  - 네임스페이스 객체에 다른 네임스페이스 객체를 프로퍼티로 추가해서 계층적으로 구성가능
- 모듈 패턴
  - 클래스를 모방해서 관련이 있는 변수와 함수를 모아 실행함수로 감쌈 → 모듈 생성
  - 클로저,, 를 기반으로 동작함
  - 캡슐화 가능 (은닉 ㄱㄴ)
    - 객체의 상태를 나타내는 프로퍼티와
    - 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는것
    - 짜스에는 public, private와 같은 접근 제한자를 제공하지 않기 때문에 - 반환하는 객체에 추가 여부로 결정
- ES6 모듈
  - `<script type=”module” src”lib.mjs”></script>`
  - 을 사용하면 파일 자체의 독자적인 모듈 스코프로 동작함 - 더이상 전역 변수나 window 객체의 프로퍼티로 동작하지 않음

## 15장 let, const 키워드와 블록 레벨 스코프

### 15.1 var 키워드로 선언한 변수의 문제점

- 변수 중복 선언 허용
  - 말이 되냐 진짜?
- 함수 레벨 스코프
  - if, for 등 코드 블록 안에서 선언해도 모두 전역변수
- 변수 호시으팅
  - 선언 이전에 참조할 수 있음 (undefined 반환)

### 15.2 let 키워드

- 변수 중복 선언 금지 `(SyntaxError)`
- 블록 레벨 스코프
- 변수 호이스팅 (이 발생하지 않는 것 처럼 동작함)
  - `ReferenceError` 발생
  - 선언단계 / 초기화단계가 분리되어 진행
    - 암묵적으로 엔진에 의해 선언이 먼저 실행되지만
    - 선언문에 도달했을 때 초기화됨 (TDZ)
- 전역 객체와 let
  - var 키워드 전역변수, 전역함수, 암묵적 전역(선언안하고 할당) 한 것을은 전역객체 window 의 프로퍼티가 됨
  - let은 아니다 ~

### 15.3 const 키워드

- 선언과 초기화
  - 선언과 동시에 초기화해야함 `(SyntaxError)`
  - 블록 레벨 스코프
  - 재할당 금지 (상수)
    - Primitive 아닌 Object는 재할당 없이도 변경이 가능하기 때문에 .. **불변을 의미하지는 않음**

### 15.4 var vs let vs const

- ES6부터는 var 아웃
- 재할당이 필요하면 let
- 읽기 전용으로 사용하는 원시값과 객체에는 const

## 16 프로퍼티 어트리뷰트

### 16.1 내부 슬롯과 내부 메서드

- ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드
- 사양에 정의된 대로 구현되어 엔진에서 실제로 동작하지만, 개발자가 직접 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아님
  - 근디 일부에 한해 간접적으로 접근은 가능 `o.__proto__`

### 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

- 프로퍼티를 생성할 때 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의
  - 상태란 .. 값, 갱신가능여부, 열거가능여부, 재정의가능여부
  - value, writable, enumerable, configurable
    `Object.getOwnPropertyDescriptor` 메서드를 사용해 간접적으로 확인할 수 있음

### 16.3 데이터 프로퍼티와 접근자 프로퍼티

- 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티
  ```jsx
  [[Value]]
  - 프로퍼티 키를 통해 값에 접근하면 반환되는 값

  [[Writable]]
  - 값의 변경 가능 여부를 나타내며 불값 가짐

  [[Enumerable]]
  - 값의 열거 가능 여부를 나타내며 불값 가짐
  - false인 경우 for ... in 문이나 Object.keys 등으로 돌릴 수 없음

  [[Configurable]]
  - 프로퍼티의 재정의 가능 여부를 나태내며 불값 가짐
  - false인 경우 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지됨
  - 단 Writable === true 인 경우 Value의 변경과 Writable을 false로 변경하는 것은 허용됨
  ```
- 접근자 프로퍼티: 자체적으로 값을 갖고 있지 않은 - 다른 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티
  ```jsx
  [[Get]]
  - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수
  - 접근하면 게터 함수 호출하고 그 결과가 프로퍼티 값으로 반환

  [[Set]]
  - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수
  - 값을 저장하면 세터가 호출되고 그 결과가 프로퍼티 값으로 저장됨

  [[Enumerable]]

  [[Configurable]]
  ```
  ```jsx
  const person = {
  	// 데이터프로퍼티
  	firstName: 'Ungmo',
  	lastName: 'Lee'

  	get fullName() {
  		return `${this.firstName} ${this.lastName}`;
  	},
  	set fullName(name) {
  		[this.firstName, this. lastName] = name.split(' ');
  	},

  	// 데이터 프로퍼티를 통한 프로퍼티 값의 참조
  	console.log(person.firstName + ' ' + person.lastName);

  	// 접근자 프로퍼티를 통한 프로퍼티 값의 저장
  	person.fullName = 'Heegun Lee';

  	// 접근자 프로퍼티를 통한 프로퍼티 값의 참조
  	console.log(person.fullName)
  ```

### 16.4 프로퍼티 정의

- 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의 하는 것
  값의 갱신을 가능하도록 할 것인지, enumerable하게 할 것인지, 재정의 가능하게 할 것인지 등 …
- `Object.defineProperty` 통해서 할 수 있음

```jsx
const person = {};

// 데이터 프로퍼티 정의
Object.defineProperty(person, 'firstName', {
  value: 'Ungmo',
  writable: true,
  enumerable: true,
  configurable: true,
});

// 접근자 프로퍼티 정의
Object.defineProperty(person, 'firstName', {
  get() {
    return firstName;
  },
  set() {
    this.firstName = firstName;
  },
  enumerable: true,
  configurable: true,
});
```

- `Object.defineProperties` 통해서 한 번에 여러개 프로퍼티 정의 가능

### 16.5 객체 변경 방지

- 객체는 변경 가능한 값이므로 재할당 없이 직접 변경할 수 있음
  - 프로퍼티의 추가와 삭제, 값의 갱신, defineProperty 등의 메서드를 이용해서 어트리뷰트 재정의 가능

![스크린샷 2024-01-25 오전 12.43.02.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/cf76ac98-01cc-46d6-a8ba-2b4b656a6d4d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-25_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.43.02.png)

- 불변 객체
  - Object.freeze를 해도 중첩 객체까지 동결할 수는 없음
  - 하려면 .. 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 호출해야됨
