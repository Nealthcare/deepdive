# 26장 ES6 함수의 추가 기능

## 26.1 함수의 구분

ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. (모든 함수는 `callable` 이면서 `constructor` 다.)

콜백 함수나, 객체에 바인딩된 함수도 constructor이기 때문에 불필요한 프로토타입 객체를 생성하기에 문법상 혼란스러울 뿐 아니라 성능상의 문제가 있다.

ES6에서는 이를 해결하기 위해 함수를 사용 목적에 따라 일반 함수, 메서드, 화살표 함수 세 가지로 나누었다.

| 구분 | constructor | prototype | super | arguments |
| --- | --- | --- | --- | --- |
| 일반 함수(Normal) | O | O | X | O |
| 메서드(Method) | X | X | O | O |
| 화살표 함수(Arrow) | X | X | X | X |

## 26.2 메서드

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]` 를 갖는다. 따라서 super 키워드를 사용할 수 있다.

> 프로퍼티 값으로 익명 함수 표현식을 할당하는 ES6 이전의 방식은 사용하지 않는 것이 좋다.
> 

*아까 그렇게 쓴거같은데*

## 26.3 화살표 함수

*( ) ⇒ { … }*

- 매개변수가 한 개인 경우 소괄호를 생략할 수 있다.
- 매개변수가 없는 경우 소괄호를 생략할 수 없다.
- 함수 몸체가 하나의 문인 경우 중괄호를 생략할 수 있다. 이때 함수 몸체 내부가 값으로 평가될 수 있는 표현식인 문이라면 **암묵적으로 반환**된다.
  
    = return 붙여서 성립하면 암묵적 반환 가능
    
- 객체 리터럴을 반환하는 경우 소괄호로 감싸줘야 한다
  
    ```jsx
    const haha = (q, p) => ({ q, p });
    ```
    
- 화살표 함수도 IIFE로 사용할 수 있다.

> 콜백 함수로서 정의할 때 유용하다
> 

*JS 모르고 쓸때는 C++ 람다식 비슷하게 콜백함수용 문법인줄 알았었다.*

- this: 상위 스코프의 this를 그대로 참조한다 (lexical this)
    - super, arguments 도 동일하다

## 26.4 Rest 파라미터

```jsx
function zxcvbn(a, b, ... rest) { ... }
```

(매개변수에 할당된 인수를 제외한) 인수들의 목록을 배열로 전달받는다. 따라서 가장 마지막 파라미터여야 한다.

함수 객체의 length 프로퍼티에 rest 파라미터는 반영되지 않는다.

*arguments는 불편한점이 많으니 Rest를 쓰자*

## 26.5 매개변수 기본값

```jsx
function youKnowThis(a = 1, b = 4) { ... }
```

매개변수에 인수를 전달하지 않은 경우와 undefined를 전달한 경우 적용된다.

- Rest 파라미터에는 기본값 지정이 불가능하다
- 기본값을 정의한 매개변수는 length에 반영되지 않고, arguments에 기본값이 반영되지도 않는다.

# 27장 배열

배가 열개면 배열

당신이 파스칼을 하는게 아니라면 배열의 인덱스는 0부터 시작한다

```
TMI) 사실 파스칼의 배열 시작 인덱스는 지정 가능하다
```

배열은 사실 객체다

```jsx
const thisIsArray = [1,2,3];
typeof thisIsArray // object
```

그러나 일반적인 객체와는 다르다

| 구분 | 객체 | 배열 |
| --- | --- | --- |
| 구조 | 프로퍼티 키와 프로퍼티 값 | 인덱스와 요소 |
| 값의 참조 | 프로퍼티 키 | 인덱스 |
| 값의 순서 | X | O |
| length 프로퍼티 | X | O |

## 27.2 자바스크립트 배열은 배열이 아니다

자료구조의 배열은 동일한 크기의 메모리 공간이 연속적으로 나열된 **밀집 배열**dense array 이다.

따라서 임의 요소의 접근이 O(1)로 빠르다. 대신 중간에 다른 요소를 삽입하거나 삭제할 때 다른 요소를 이동시켜야 하는 단점이 있다.

자바스크립트의 배열은 각각의 메모리 공간이 동일한 크기가 아니어도 되며, 연속적이지 않을 수 있는 **희소 배열**sparse array 이다.

이처럼 자바스크립트의 배열은 배열의 동작을 흉내낸 특수한 객체이다. 해시 테이블로 구현된 객체이므로 인덱스를 통한 접근은 일반 배열보다 느리지만 요소의 삽입과 삭제 시에는 일반 배열보다 빠른 성능을 기대할 수 있다.

> 인덱스로 배열 요소에 접근할 때 일반적인 배열보다 느릴 수밖에 없는 구조적인 단점을 보완하기 위해 대부분의 모던 자바스크립트 엔진은 배열을 일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화하여 구현했다.
> 

[Elements kinds in V8 · V8](https://v8.dev/blog/elements-kinds)

## 27.3 length 프로퍼티와 희소 배열

- length 프로퍼티는 `0` ~ `2^32-1` 사이의 값을 가진다
- length 프로퍼티 값은 요소를 추가/삭제할 때 자동 갱신되지만 수동으로 할당할 수 있다.
- 배열 길이보다 작은 값을 지정하면 배열의 길이가 줄어든다.
- 배열 길이보다 큰 값을 할당하면 length에는 반영되지만 배열에는 **변경이 없다**.
- length 프로퍼티와 요소의 개수는 일치하지 않을 수 있다
  
    ```jsx
    const sparseArray = [ , 2, , , 5]
    sparseArray.length // 5
    sparseArray[0] // undefined
    ```
    
    length ≥ 배열의 실제 요소 개수
    
    희소 배열은 성능에도 좋지 않고 배열의 개념과도 다르므로 그러지 말자
    

## 27.4 배열 생성

```jsx
new Array(10) // [empty * 10]
new Array() // []
new Array(1, 2, 3) // [1, 2, 3]
new Array({}) // [{}]
Array(1, 2) // [1, 2]

Array.of(1) // [1]

// 인덱스로 프로퍼티를 접근 가능하고 length를 가진 객체는 유사 배열 객체
Array.from({ length: 2, 0: 'q', 1: 'p' }) // ['q', 'p']
Array.from('qilip') // ['q', 'i', 'l', 'i', 'p']
Array.from({ length: 2 }) // [undefined, undefined]

// 첫번째 인자로 생셩된 배열의 (요소값, 인덱스) => 반환값으로 구성된 배열 반환
Array.from({ length: 3 }, (_, i) => i) // [0, 1, 2]
```

## 27.8 배열 메서드

원본 배열을 직접 변경하는 메서드만 기록하겠습니다.

- push
- pop
- unshift
- shift
- splice
- reverse
- fill

## 27.9 배열 고차 함수

원본 배열을 직접 변경하는 메서드

- sort
    - 유니코드 코드 포인트 순 정렬이므로, 숫자를 정렬할때 문자열로 변환 후 정렬된다 생각할것
    - 숫자순으로 정렬하거나 할때는 비교 함수를 인수로 전달하면 된다
    - ~~완성형 한글 전체를 가나다로 재배치한 유니코드 2.0 한국 대표에게 감사를~~
    - 알고리즘은 quicksort → timsort (ES10)
      
        [Tim sort에 대해 알아보자](https://d2.naver.com/helloworld/0315536)
    
- forEach의 콜백 함수에서 변경 가능

# 28장 Number

## 28.1 Number 생성자 함수

`new Number()` 시 `[[NumberData]]` (ES5에서는 `[[PrimitiveValue]]`)에 값을 할당한 Number 래퍼 객체를 생성한다.

- 인수가 없으면 0, 인수가 숫자면 해당 숫자, 인수가 숫자로 변환이 불가능하면 NaN

## 28.2 Number 프로퍼티

- EPSILON: 부동소수점 오차 보정에 사용한다
  
    [계산기 엡실론](https://ko.wikipedia.org/wiki/계산기_엡실론)
    
- MAX_VALUE: 가장 큰 양수
- MIN_VALUE: 가장 작은 **양수**
- MAX_SAFE_INTEGER: 안전하게 표현 가능한 가장 큰 정수 (약 9천조)
- MIN_SAFE_INTEGER: 맥스값에 -붙은거
- POSITIVE_INFINITY = `Infinity`
- NEGATIVE_INFINITY = `-Infinity`
- NaN = `NaN`

## 28.3 Number 메서드

is~ 메서드들은 암묵적 타입변환을 하지 않는다. (동일 이름의 빌트인 전역 함수는 암묵적 타입변환 O)

to~ 메서드들은 문자열로 반환한다.

- isFinite: 정상적인 유한수인지 (NaN 또는 Infinity가 아닌지)
- isInteger: 정수인지
- isNaN: NaN인지
- isSafeInteger: 안전한 정수인지
- toExponential: 숫자를 지수 표기법으로 변환한다. 이때 모호함을 피하기 위해 괄호로 감싸거나 공백을 두어야 한다
- toFixed: 지정 자리 밑에서 반올림, 인수 생략시 0
- toPrecision: 인수 전체 자리수까지 유효하도록 나머지 반올림, 기본값 0 전체 자리수 유효
- toString: 문자열로 변환, 인수는 진법(2~36) 기본 10진법