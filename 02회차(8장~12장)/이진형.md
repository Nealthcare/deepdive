# 2회차 (8~12장 / 0122 (월))

## 8장 제어문

조건에 따라 코드 블록을 실행하거나 반복실행 할 때 사용

### 8.1 블록문

- {문을 중괄호로 묶은 것}
- 블록문의 끝에는 세미콜론을 붙이지 않음

### 8.2 조건문

- 조건식의 평가 결과에 따라 블록문의 실행을 결정
- if … else
  - if 문의 조건식은 bool값으로 평가되어야 함 (아닌경우 강제 변환)
- switch
  - 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문 실행
  - 일치하는 case가 없다면 default문으로 이동
  - case 안에 break문 사용하지 않으면 탈출 안함 (default까지 이동)

### 8.3 반복문

- 조건식의 평가 결과가 참일 때 동안 블록문을 실행
- for `for (var i = 0; i < 2; i++)`
- while `while (count < 3)`
- do… while
  - 코드 블록을 먼저 실행하고 조건식을 평가 (한번 이상은 무조건 실행)
- break
  - 레이블, 반복문의 코드 블록을 탈출
- continue
  - 반복문의 코드 블록 실행을 현 지점에서 중단하고 증감식으로 실행 흐름을 이동

## 9장 타입변환과 단축평가

### 9.1 타입 변환이란

- 명시적 타입 변환, 암묵적 타입 변환
- 표현식을 평가하는 과정에서 암묵적으로 생성된 값은 변수에 재할당되지 않음
  `console.log(x + ‘ ‘) // x === 10`

### 9.2 암묵적 타입변환

- 원시타입 중 하나로 타입을 자동변환
- 문자열 타입으로 변환
  `1 + ‘2’ // ‘12’, bool, undefined, null, objects ...`
- 숫자 타입으로 변환
  `1 - ‘1’ // 0` 불가능할 때는 NaN
  - 산술 연산자, 비교 연산자 등 표현식의 문맥이 숫자를 나타내야 할 때 숫자 타입으로 암묵적 변환
- 불리언 타입으로 변환
  if, for 과 같은 제어문 또는 조건식은 논리적 참 거짓으로 평가되어야 하는 표현식

### 9.3 명시적 타입변환

- 문자열 타입으로 변환
  - `String(), toString(), + ‘ ‘`
- 숫자 타입으로 변환
  - `Number(), parseInt(), parseFloat(), +, +1`
- 불리언 타입으로 변환
  - `Boolean(), !!`

### 9.4 단축평가

- 논리 연산자를 이용한 단축평가
  ![스크린샷 2024-01-22 오전 12.24.13.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/85be9a68-06c4-40b3-ab9e-ca3afe20287b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.24.13.png)
  - &&는 전항 true시 후항까지 계산
  - || 는 전항 true시 전항만 계산
- if문 대체 가능
  - null, undefined 가드 / 매개변수에 기본값 설정할때 사용가능
- 옵셔널 체이닝 ?.
  - 좌항이 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항에 접근
    `var value = elem?.value // elem이 null일 때 undefined`
  - 도입 이전에는 &&로 널가드
    `var length = str && str.length`
  - 옵셔널 체이닝은 Falsy 값이어도 null이나 undefined가 아니면 우항에 접근가능
    `(false, 0, -0, NaN, ‘ ’)`
- null 병합
  - 좌항의 피연산자가 null 또는 undefined인 경우 우항을 반환, 그렇지 않으면 좌항을 반환
    `var foo = null ?? ‘default string’`

## 10장 객체 리터럴

### 10.1 객체

- Primitive 을 제외한 나머지 함수, 배열, regex등 모두 객체
- 원시값은 변경 불가능하지만 객체는 변경 가능한 값
- 객체는 0개 이상의 프로퍼티로 구성된 집합
  - 모든 값은 프로퍼티 값이 될 수 있음 (함수도)
  - 함수가 프로퍼티 값 일때 메서드라 부름
    ```json
    var object = {
      propertyKey: propertyValue,
      propertyKey2: function () {} // 얘는 메소드
    };
    ```

### 10.2 객체 리터럴에 의한 객체 생성

- 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 데 반해
- JS는 프로토타입 기반 객체지향 언어로서 다양한 방법으로 생성 가능
  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create
  - 클래스
- 객체 리터럴로 생성하려면
  ```json
  var person = {
    name: 'Lee',
  	sayHello: function() {
  		console.log(this.name)
  	}
  }
  ```
- 객체 리터럴은 값으로 평가되기 때문에 중괄호는 코드 블록이 아님

### 10.3 프로퍼티

- 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성됨
  `propertyKey: propertyValue 모든 문자열 또는 심벌 값: 모든 값`
- 키에 식별자 네이밍 규칙을 따르면 따옴표 생략 가능
  `firstName: ‘ungmo’   ’last-name’: ‘lee’`
- 키를 동적으로 생성 가능
  `obj[key] = ‘world’`
- 빈 문자열도 키로 생성 가능
- 암묵적 형변환도 가능
- 예약어도 가능
- 중복선언시 에러 발생하지 않지만 나중에 선언한 프로퍼티가 덮어씀

### 10.4 메서드

- 프로퍼티 값이 함수일 경우 메서드라 부른다 나중에 ..

### 10.5 프로퍼티 접근

- 마침표 표기법 .
- 대괄호 표기법 […]
  - 대괄호 내부에는 항상 따옴표로 감싸서 사용
- 존재하지 않는 프로퍼티 접근하면 undefined 반환
  - ReferenceError 발생하지 않는다 ~

```json
var person = {
  'last-name': 'lee',
  1: 10
}

person.'last-name' // SyntaxError: Unexpected String
person.last-name // 브라우저 환경: NaN
person.last-name // Node 환경: ReferenceError: name is not defined
```

- person.last-name 시에 엔진에서 person.last 평가함
- person 객체에는 last인 프로퍼티가 없음으로 undefind-name
- name이라는 선언이 없으니 ReferenceError
- 브라우저 환경에서는 name이라는 전역 변수가 암묵적으로 존재 (빈 문자열)

### 10.6 프로퍼티 값 갱신

- 갱신

### 10.7 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하면 동적으로 생성

### 10.8 프로퍼티 삭제

- delete 연산자로 객체의 프로퍼티 삭제 가능
- 존재하지 않는 프로퍼티를 삭제하면 에러 없이 무시

### 10.9 ES6의 객체 리터럴 확장 기능

- 프로퍼티 축약 표현 (property shorhand)
  const obj = {x, y}
- 계산된 프로퍼티 이름

  - `obj[prefix + ‘-’ + ++i] = i {prop-1: 1}`

- 메서드 축약 표현

  - 프로퍼티 값으로 함수 할당

  ```json
  const obj = {
    name: 'lee',
  	sayHi() {
  		console.log(this.name)
  	}
  }
  ```

## 11장 원시 값과 객체의 비교

- 원시 타입: 변경 불가능한 값
  - 할당시 변수(확보된 메모리 공간)에 실제 값이 저장
- 객체 타입: 변경 가능한 값
  - 할당시 변수(확보된 메모리 공간)에 참조값이 저장

### 11.1 원시 값

- 한번 생성된 원시 값은 변경할 수 없음
  - 값이 변경 불가 (변수가 X), 상수와 차이점 유의
- 변수를 재할당 할 때 새로운 메모리 공간을 부여 후 변수가 참조하는 메모리 주소 변경
  ![스크린샷 2024-01-22 오전 7.42.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/9c958f05-470e-45c0-a125-bae24bf2b25e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_7.42.57.png)
- 원시 타입별로 메모리 크기가 정해져 있음
  - ECMAScript 사양에 문자열 (2바이트) 숫자(8바이트) 이외에 규정되어 있지 않음
- 문자열은 유사 배열 객체

```json
var str = 'string'
str[0] // s
str[0] = 'S' // 에러 발생하지 않지만 값도 안바뀜
```

- 값에 의한 전달

```json
var score = 80
var copy = score

변수에 변수를 할당 시 새로운 숫자 값 80이 생성되어 copy 변수에 할당됨 (다른 메모리 공간)
```

![스크린샷 2024-01-22 오전 7.51.02.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/e9f000e9-6671-49a6-98ff-b09212d508fa/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_7.51.02.png)

### 11.2 객체

- 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가하고 삭제할 수 있음
- 해시 테이블과 유사한 방법으로 객체 구현
- 변경 가능한 값
  - 메모리 주소를 통해 메모리 공간에 접근하면 참조값(메모리 공간의 주소, reference value)에 접근할 수 있음
    ![스크린샷 2024-01-22 오전 8.05.34.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/74e2faa2-fc6e-4cf6-84bc-161e71e3d6e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.05.34.png)
  - 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음 (변수의 참조 값은 변경되지 않음)
  - 원시 값처럼 복사해서 새롭게 생성한다면 비용이 큼

### 얕은 복사와 깊은 복사

- 객체에 중첩되어 있는 객체의 경우 참조 값을 복사함
  - 두개의 식별자가 하나의 객체를 공유
  - 어느 한쪽에서 프로퍼티 값을 변경하거나 추가, 삭제하면 서로 영향을 주고받음

```json
const o = { x: { y: 1 } }

// shallow copy
const c1 = { ...o }
console.log(c1 === o) // false
console.log(c1.x === o.x) // true
```

![스크린샷 2024-01-22 오전 8.10.25.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/6cb83b43-477d-4432-a862-482398ddd8c0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.10.25.png)

## 12장 함수

### 12.1 함수란

- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- 매개변수, 인수, 반환값

### 12.2 함수를 사용하는 이유

- 코드의 재사용 가능
  - 유지보수의 편의성, 코드의 신뢰성, 코드의 가독성

### 12.3 함수 리터럴

- 함수도 함수 리터럴로 생성할 수 있음 - 함수는 객체 (1급 객체)

### 12.4 함수 정의

```jsx
1. 함수 선언문
function add(x, y) {
	return x + y
}
2. 함수 표현식
var add = function add(x, y) {
	return x + y
}
3. Function 생성자 함수
var add = new Function('x', 'y', 'return x+y')
4. 화살표 함수
var add = (x, y) => x + y
```

- 함수 선언문
  - 함수 리터럴과 형태가 동일하지만 함수 이름을 생략할 수 없다
  - 표현식이 아닌 문
    - 실행시키면 undefined 출력
    - 문은 변수에 할당할 수 없지만 함수 리터럴과 같은 형태로 문맥을 통해 중의적 표현

```jsx
function foo() {
  console.log("foo");
}
foo()(function bar() {
  console.log("bar");
});
bar();
```

- bar은 호출할 수 없음 (외부에서 참조할 수 없음)
- foo는 호출할 수 있음
  - 엔진에서 함수룰 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성, 함수 객체를 할당
  - 함수 이름으로 호출한 것이 아닌 함수 객체를 가리키는 식별자로 호출
    ![스크린샷 2024-01-22 오전 8.22.15.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/d543e018-4440-46ca-b99f-f262fceb5fe3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.22.15.png)
- 함수 표현식
  - JS의 함수는 일급 객체 - 값처럼 자유롭게 사용할 수 있음
  - 익명함수로 사용할 수 있음
- 함수 생성 시점과 함수 호이스팅
  - 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있음
    - 함수 선언문도 런타임 이전에 엔진에 의해 먼저 실행됨 (객체와 식별자가 생성)
  - 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없음
    - 함수 표현식은 값이기 때문에 런타임에 평가됨 (undefined로 평가됨)
    - 이 시점에 함수를 호출하는 것은 undefined를 호출하는 것과 같아서 타입에러 발생
- Function 생성자 함수
  - 클로저 생성하지 않음
- 화살표 함수
  - 항상 익명 함수로 정의

### 12.5 함수 호출

- 매개 변수와 인수
  - 함수가 호출되면 암묵적으로 몸체 내에서 매개 변수가 생성되고 undefined로 초기화된 이후 인수 할당
  - 인수가 부족해서 할당되지 않은 값은 undefined
  - 인수가 더 많은 경우 초과된 인수는 무시 (arguments 객체의 프로퍼티로 보관됨)
- 인수 확인
  - 매뉴얼하게 체크하는 방법도 있고
  - 매개변수 기본값을 사용할 수 있음
    - 매개변수에 인수를 전달하지 않았을때와 undefined를 전달했을 경우에만 유효함
- 매개변수의 최대 개수
  - 이상적인 함수는 한가지 일만 해야하며 가급적 작게
- 반환문
  - 함수 실행을 중단하고 몸체를 빠져나감
  - return 뒤에 오는 표현식을 평가해 반환 (지정하지 않으면 undefined가 반환)

### 12.6 참조에 의한 전달과 외부 상태의 변경

- 매개변수로 전달받은 원시 값과 객체의 상태를 함수 내부에서 변경했을 때
  - 객체는 원본 변경 가능

### 12.7 다양한 함수의 형태

- 즉시 실행 함수

  ```jsx
  (function foo() {
    var a = 3;
    return a;
  })();
  ```

  - (그룹 연산자로 감싸야함)

- 재귀함수

  - 표현식으로 정의한 함수 내부에서는 함수를 가리키는 식별자로도 자기 자신을 재귀호출 가능

- 중첩 함수

  - 함수 내부에 정의된 함수

- 콜백 함수

  - 콜백함수: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
  - 고차함수: 전달받은 함수

- 순수 함수와 비순수 함수

  - 부수 효과가 없는 함수: 순수 함수
    - 오직 매개변수를 통해 값을 반환함 (동일한 인수가 전달되면 언제나 동일한 값을 반환)
  - 부수 효과가 있는 함수: 비순수 함수
    - 외부 상태에 의존하거나 외부 상태를 변경
