# 스터디 4회차 - 17장 ~ 19장

생성일: 2024년 1월 26일 오전 1:01
태그: Dev, JavaScript
Reference: 모던 자바스크립트 Deep Dive

# 17장 생성자 함수에 의한 객체 생성

`new`

## 17.1 Object 생성자 함수

```jsx
const imObj = new Object();
```

> 생성자 함수constructor란 new 연산자와 함꼐 호출하여 객체(인스턴스)를 생성하는 함수를 말한다.
자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인 생성자 함수를 제공한다
> 

```jsx
Date나 Promise 정도나 좀 써본듯
```

## 17.2 생성자 함수

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

→ 동일한 구조의 프로퍼티를 가진 객체를 여러개 만들때 번거롭다.

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

→ 생성자 함수를 일종의 템플릿(클래스) 처럼 사용하여 편리하게 생성가능

```jsx
function Charactor(level) {
	this.level = level;
	this.getAtk = function () {
		return this.level * 2 + 1;
	};
}

const 짱멋진캐릭터 = new Charactor(10);
const 토끼곤듀 = new Charactor(299);

console.log(짱멋진캐릭터.getAtk()); // 21
console.log(토끼곤듀.getAtk()); // 599
```

> **this**
this는 자신의 프로퍼티나 메서드를 참조하기 위한 **자기 참조 변수**self-referencing variable다. this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.
일반 함수로서 호출 → 전역 객체 (window, global)
메서드로서 호출 → 메서드를 호출한 객체(마침표 앞의 객체)
생성자 함수로서 호출 → 생성자 함수가 (미래에) 생성할 인스턴스
> 

### 17.2.3 생성자 함수의 인스턴스 생성 과정

*암묵의 향연*

암묵적으로 인스턴스를 생성 → 암묵적으로 인스턴스 초기화 → 암묵적으로 인스턴스 반환

**1. 인스턴스 생성과 this 바인딩**

암묵적으로 빈 객체가 생성된다. 그리고 이 인스턴스는 this에 바인딩된다. 이 처리는 함수 몸체 런타임 이전에 실행된다.

> 바인딩name binding: 식별자와 값을 연결하는 과정
> 

```jsx
function Naver(cafe) {
	console.log(this); // Naver {}
}
```

**2. 인스턴스 초기화**

생성자 함수의 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.

**3. 인스턴스 반환**

생성자 함수 내부의 모든 처리가 끝나면 this가 암묵적으로 반환된다.

this가 아닌 다른 객체를 명시적으로 반환하면 return 문에 명시한 **객체**가 반환된다. 단, 명시적으로 **원시 값**을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환된다.

⇒ 생성자 함수 내부에선 반드시 return을 생략해야 한다

### 17.2.4 내부 메서드 [[Call]]과 [[Construct]]

- 함수는 함수 호출 뿐만 아니라 생성자 함수로서 호출할 수 있다.
- 함수는 객체이므로 일반 객체와 같이 프로퍼티와 메서드를 소유할 수 있다.

함수는 일반 객체와는 다르게 호출할 수 있다. 따라서 함수는 함수 객체만을 위한 `[[Environment]]`, `[[FormalParameters]]` 등의 내부 슬롯과 `[[Call]`, `[[Contstruct]]` 같은 내부 메서드를 추가로 가지고 있다.

- `[[Call]]` : 일반 함수로서 호출되면 호출
    - 가지고 있으면 callable
- `[[Construct]]` : new 연산자와 함께 생성자 함수로서 호출되면 호출
    - 가지고 있으면 constructor, 없으면 non-constructor

호출할 수 없는 객체는 함수 객체가 아니므로 모든 함수는 callable이다. 하지만 모든 함수 객체가 `[[Construct]]` 를 갖는 것은 아니다.

### 17.2.5 constructor와 non-constructor의 구분

함수 정의 방식에 따라 구분한다

- constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)
- non-constructor: 메서드(ES6 메서드 축약 표현), 화살표 함수

ECMAScript 사양에서 메서드는 ES6 메서드 축약 표현만을 메서드로 인정한다.

```jsx
const qilip = {
	beHappy() {}
};

new qilip.beHappy(); // TypeError: qilip.beHappy is not a constructor
```

### 17.2.6 new 연산자

생성자 함수를 new 없이 호출할 경우와, 일반 함수를 new 붙일경우 위 설명대로 원하지 않게 동작할 수 있다. 그러므로 생성자 함수는 PascalCase를 사용하자

### 17.2.7 new.target

***☆IE 미지원★***

생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 ES6에서 생긴 메타 프로퍼티

> new 연산자와 함꼐 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined다.
> 

```jsx
function Sleep(alongtimeago) {
	if (!new.target) { // new 없이 호출되면 undefined
		return new Sleep(alongtimeago); // 생성자 함수를 재귀 호출 후 생성된 인스턴스 반환
	}

	// 초기화 과정...
}
```

```jsx
// IF IE6
if (!(this instanceof Sleep)) // new와 함께 호출되지 않았으면 this는 window를 가리킨다
```

대부분의 빌트인 생성자 함수는 new 연산자의 유무에 따라 적절한 값을 반환한다.

Object, Function → new 있던 없던 동일하게 동작

String, Number, Boolean → 없으면 타입변환

# 18장 함수와 일급 객체

## 18.1 일급 객체

다음 조건을 만족하는 객체를 일급 객체라 한다.

1. 무명의 리터럴로 생성할 수 있다. (런타임에 생성이 가능하다)
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

⇒ 자바스크립트의 함수는 일급 객체다.

이는 함수형 프로그래밍을 가능케 한다.

## 18.2 함수 객체의 프로퍼티

`console.dir` 명령어로 함수 객체의 내부를 살펴볼 수 있다.

`arguments`, `caller`, `length`, `name`, `prototype` 프로퍼티는 일반 객체에는 없는 함수 객체의 데이터 프로퍼티다.

`__proto__` 는 접근자 프로퍼티로, 함수 객체 고유의 프로퍼티가 아닌 `Object.prototype` 객체의 프로퍼티를 상속받은 것이다.

### 18.2.1 arguments 프로퍼티

프로퍼티 값은 arguments 객체로, 함수 호출시 전달된 인수의 정보를 담고 있는 순회 가능한iterable 유사 배열 객체이며, 함수 내부에서 지역 변수처럼 사용된다.

> 함수 객체의 arguments 프로퍼티는 일부 브라우저에서 지원하고 있지만 ES3 표준에서 폐지되었다. 따라서 Function.arguments 같은 사용법은 권장되지 않으며, 함수 내부에서 지역 변수처럼 사용 가능한 arguments 객체를 참조하도록 한다.
> 

arguments 객체는 가변 인자 함수를 구현할 때 유용한다.

> ES6에서 도입된 이터레이션 프로토콜을 준수하면 이터러블이 된다. ES6부터 arguments 객체는 유사 배열 객체이면서 이터러블이다.
> 

ES6에서 Rest 파라미터가 도입되면서 현재는 arguments 객체의 중요성이 덜하다.

### 18.2.2 caller 프로퍼티

비표준이고 앞으로도 비표준일 예정이다. 이왕이면 쓰지말자

함수 자신을 호출한 함수를 가리킨다. (상위 함수, 브라우저환경에서 바로 호출한경우 null, Node.js 에서는 48장 모듈 참고)

### 18.2.3 length 프로퍼티

함수를 정의할 때 선언한 매개변수의 개수 (arguments.length 와는 다름)

### 18.2.4 name 프로퍼티

ES6에서 표준으로 편입되었다. 단 편입되면서 동작이 다소 변경되었다.

**함수 이름**을 나타낸다.

익명 함수 표현식에서 ES5까지는 빈 문자열이었지만 ES6에서는 함수 객체를 가리키는 **식별자**를 값으로 갖는다.

### 18.2.5 __proto__ 접근자 프로퍼티

`[[Prototype]]` 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티

객체 리터럴 방식으로 생성한 객체는 Object.prototype의 프로퍼티를 상속받는다.

### 18.2.6 prototype 프로퍼티

생성자 함수로 호출할 수 있는 함수 객체 (constructor) 만이 소유하는 프로퍼티다.

함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.

# 19장 프로토타입

자바스크립트짱짱 프로토타입 최고 … 라고 MDN에서도 말했다

[상속과 프로토타입 - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#성능)

뇌절논문링크 *(자바스크립트는 근본없는 언어가 아니에요)*

[](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=30fcb7807ce73f16222761b97e36154f12349efb)

를 쉽게 보기 위한 해설

[자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/자바스크립트는-왜-프로토타입을-선택했을까-997f985adb42)

> **클래스**
자바스크립트의 클래스는 프로토타입 패턴의 문법적 설탕에 가깝다
그러나 프로토타입 기반 생성 패턴과 완전히 동일하지는 않으며, 새로운 객체 생성 방법으로 보는게 합당하다 → 25장 참고
> 

## 19.1 객체지향 프로그래밍

상태와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조인 객체 기반

## 19.2 상속과 프로토타입

같은 인스턴스가 동일한 메서드를 중복 소유하는건 비효율적이므로 JS에서는 프로토타입을 기반으로 상속을 구현한다.

생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입의 모든 프로퍼티와 메서드를 상속받는다.

## 19.3 프로토타입 객체

> 모든 객체는 하나의 프로토타입을 갖는다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다.
> 

`__proto__` 접근자 프로퍼티를 `Object.prototype` 으로부터 상속받아 사용한다. (ES6 표준화)

접근자 프로퍼티를 사용하는 이유는 서로가 서로의 프로토타입이 되는 상황을 방지하기 위해서다.

직접 상속 등 `__proto__` 를 사용할 수 없는 경우가 있기에 코드 내 사용은 권장하지 않는다.

→ 대신 프로토타입 취득은 `Object.getPrototypeOf` , 교체는 `Object.setPrototypeOf` 사용

함수 객체의 `prototype` 프로퍼티는 생성자 함수가 생성할 객체의 프로토타입을 가리킨다.

결국 `prototype` 과 `__proto__` 는 동일한 프로토타입을 가리키지만 사용 주체만 다르다.

모든 프로토타입은 `constructor` 프로퍼티를 갖고 이는 자신을 참조하고 있는 생성자 함수를 가리킨다. (생성자 함수 객체가 생성될 때 이뤄진다)

## 19.4 리터럴 표기법**에 의해 생성된 객체의 생성자 함수와 프로토타입**

- 인수가 전달되지 않았을 때 추상 연산 `OrdinaryObjectCreate`를 내부적으로 호출해 빈 객체를 생성한다.
    - [new.target](http://new.target) 확인이나 프로퍼티 추가 처리 등 세부 내용이 다르다.
- class asdf extends Object와 같이 `[new.target](http://new.target)` 이 undefined나 Object가 아닌 경우 인스턴스 → asdf.prototype → Object.prototype 순으로 체인이 형성된다.
- Number와 String 객체 생성처럼 인수가 전달된 경우, 인수를 객체로 반환한다.

따라서 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.

함수의 경우 Function 생성자 함수가 함수 객체를 생성한 것이 아니지만 constructor 프로퍼티를 통해 확인해보면 생성자 함수가 Function 생성자 함수다.

리터럴 표기법에 의해 생성된 객체도 프로토타입이 필요하므로 가상적인 생성자 함수를 갖는다.

> 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.
> 

## 19.5 프로토타입의 생성 시점

> 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.
> 
- 생성자 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입과 더불어 생성된다.
- 빌트인 생성자 함수가 생성되는 시점은 전역 객체가 생성되는 시점이다.

## 19.6 객체 생성 방식과 프로토타입의 결정

다양한 객체 생성 방법이 있지만 모두 추상 연산 `OrdinaryObjectCreate` 에 의해 생성된다.

## 19.7 프로토타입 체인

> 프로토타입의 프로토타입은 언제나 Object.prototype이다.
> 

프로토타입 체인의 최상위에는 항상 Object.prototype이 있다. 이를 프로토타입 체인의 종점end of prototype chain이라 한다.

체인의 종점에서도 프로퍼티를 검색할 수 없는 경우 undefined를 반환한다.

> 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘
> 
> 
> 스코프 체인은 식별자 검색을 위한 메커니즘
> 

## 19.8 오버라이딩과 프로퍼티 섀도잉

프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 인스턴스 프로퍼티로 추가한다. → 오버라이딩

이때, 프로토타입 메서드는 가려진다. → 프로토타입 섀도잉

## 19.9 프로토타입의 교체

> 프로퍼티는 임의의 객체로 교체하는 등 동적으로 객체 간의 상속 관계를 변경할 수 있다. 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체될 수 있다.
> 

### 생성자 함수에 의한 프로퍼티의 교체

이때, constructor 프로퍼티는 자바스크립트에서 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티이므로, 프로퍼티를 교체하면 constructor 프로퍼티와 생성자 함수 간 연결이 파괴되고 Object.prototype의 constructor 프로퍼티가 검색된다.

이떄 교체할 객체 리터럴에 `constructor: 생성자함수명` 과 같이 수동으로 프로퍼티를 추가하여 constructor 프로퍼티의 연결을 되살릴 수 있다.

### 인스턴스에 의한 프로토타입의 교체

> 인스턴스의 `__proto__` 접근자 프로퍼티(또는 Object.setPrototypeOf 메서드) 를 통해 프로토타입을 교체할 수 있다.
> 

> 생성자 함수를 이용한 교체는 미래에 생성할 인스턴스의 프로토타입을 교체하는 것이지만, `__proto__` 접근자 프로퍼티를 통해 프로토타입을 교체하는 것은 이미 생성된 객체의 프로토타입을 교체하는 것이다.
> 
- 생성자 함수에 의한 프로토타입 교체는 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리킨다
- 인스턴스에 의한 프로토타입 교체는 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리키지 **않는다.**

귀찮으므로 프로토타입을 직접 교체하지 말고 직접 상속 또는 ES6 클래스를 이용해 상속 관계를 구현하자.

## 19.10 instanceof 연산자

`객체 instanceof 생성자함수`

> 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 프로토타입 체인 상에 존재하면 true로 평가되고, 그렇지 않은 경우에는 false로 평가된다.
> 

```bash
오류 객체 부모 찾을때 좀 썼던 것 같다.
```

## 19.11 직접 상속

1. Object.create 메서드로 (프로토타입, ?프로퍼티 객체) 지정하여 객체 생성
    - new 연산자 없이 객체 생성 가능
    - 프로토타입 지정하여 객체 생성 가능
    - 객체 리터럴에 의해 생성된 객체 상속 가능
2. 객체 리터럴 내부에서 `__proto__` 에 의한 직접 상속
    - `__proto__: thisIsProto`
    - 더 편리하다

## 19.12 정적 프로퍼티/메서드

생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드

→ 생성자 함수도 객체이므로

- 인스턴스/프로토타입 메서드 내에서 this를 사용하지 않는다면 정적 메서드로 변경 가능
- 프로토타입 프로퍼티/메서드를 표기할 때 프로토타입을 #으로 (`Object.prototype.isPrototypeOf` →  `Object#isPrototypeOf`)

## 19.13 프로퍼티 존재 확인

1. in 연산자 (`key in object`)
2. `Object.prototype.hasOwnProperty` 메서드

## 19.14 프로퍼티 열거

1. for … in 문
    - 프로퍼티 키가 심벌이거나 [[Enumerable]]이 false 이면 순회하지 않는다
    - 프로토타입 체인에 존재하면 순회한다 (자신의 프로퍼티만 원한다면 hasOwnProperty 사용해 확인)
    - 원칙적으로 순서 미보장, 단 대부분 순서 보장하고 숫자라면 정렬
    - 배열에는 for 나 for … of, forEach 메서드 권장 (배열도 객체이므로 상속받은 프로퍼티 포함 가능하므로)
2. Object.keys/values/entries 메서드
    - keys: 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환
    - values (ES8): 프로퍼티 값을 배열로 반환
    - entries (ES8): 프로퍼티 키와 값의 쌍의 배열을 배열로 반환

??

[Super fast super property access · V8](https://v8.dev/blog/fast-super)
