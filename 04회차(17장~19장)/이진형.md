# 4회차 (17장~19장 / 0129(월))

## 17장 생성자 함수에 의한 객체 생성

### 17.1 Object 생성자 함수

- `new Object()`
- 빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있음
- 생성자 함수 constructor란 new 연산자와 함께 호출하여 객체를 생성하는 함수
  - 생성자 함수에 의해 생성된 객체를 인스턴스라 함 instance

### 17.2 생성자 함수

- 객체 리터럴에 의한 객체 생성 방식의 문제점

  - 단 하나의 객체만 생성할 수 있음
  - 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티 넣어야함
  - 프로퍼티는 다를 수 있지만 메서드는 내용이 동일한 경우가 일반적

- 생성자 함수에 의한 객체 생성 방식의 장점

  - 객체를 생성하기 위한 템플릿 (클래스) 처럼 생성자 함수를 사용할 수 있음

  ```jsx
  function Circle(radius) {
    this.radius = radius;
    this.getDiameter = function () {
      return 2 * this.radius;
    };
  }

  const circle1 = new Circle(5);
  const circle2 = new Circle(10);
  ```

- 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작함

  ```jsx
  function foo() {
    console.log(this);
  }

  foo(); // window (node.js 환경에서는 global)

  obj.foo(); // obj

  const inst = new foo(); // inst
  ```

- 생성자 함수의 인스턴스 생성 과정

  - 생성자 함수의 역할:
    - 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로 동작하여 인스턴스를 생성
    - 생성된 인스턴스를 초기화 (인스턴스 프로퍼티 추가 및 초기값 할당)

  ```jsx
  ~ new 연산자화 함께 생성자 함수를 호출하면 엔진이 거치는 과정 ~

  1. 인스턴스 생성과 this 바인딩
    - 암묵적으로 빈 객체 생성
  2. 인스턴스 초기화
  	- 생성자 함수에 기술되어 잇는 코드 (우리가 쓴거 ..) 가 실행되어
      this에 바인딩되어 있는 인스턴스 초기화
  3. 인스턴스 반환
    - 내부 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환
  ```

- 내부 메서드 [[Call]]과 [[Construct]]

  - 함수 선언문 또는 함수 표현식으로 정의한 함수는 생성자 함수로서 호출할 수 있음 (new 로)
  - 함수는 객체이므로 일반 객체와 동일하게 동작할 수 있음
    - 일반 객체가 가지고 있는 내부 슬롯과 메서드를 가지고 있음
    - 일반 객체와는 다른점 - 함수는 호출할 수 있음
  - 함수 객체만을 위한 environment, formalparameters 등의 내부 슬롯과 call, construct 같은 내부 메서드를 추가로 가지고 있음

- 내부 메서드 call을 갖는 객체를 callable (호출할 수 있는 객체 - 함수)
- 내부 메서드 construct를 갖는 객체를 constructor 라 한다. (인 함수도 있고 아닌 함수도 있음)
  ![스크린샷 2024-01-29 오전 12.41.58.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/d427624d-4100-4197-8d4a-95b49edb4da2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-29_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.41.58.png)
- constructor와 non-constructor의 구분

  - 엔진이 어떻게 구분할까? - 함수 정의를 평가해 함수 객체를 생성할 때 정의 방식에 따라 구분함
  - ECMAScript 사양에서 메서드로 인정하는 범위가 일반적인 의미의 메서드보다 좁음

  ```jsx
  const obj = {
    x() {},
  }; // <- ES6의 메서드 축약 표현만 메서드로 인정함

  const baz = {
    x: function () {},
  }; // <- 프로퍼티 x의 값으로 할당된 것은 일반 함수로 정의된 함수 (메서드가 아님)
  ```

  - 함수를 프로퍼티 값으로 사용하면 일반적으로 메서드라고 통칭하지만 … ECMA사양에서는 아님

- new 연산자

  - 일반 함수와 생성자 함수에 특별한 형식적 차이는 없음
  - new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작함 (call 대신 construct가 호출됨)
  - new 연산자와 함께 호출하는 함수는 constructor 이어야 함 (생성자 함수로서 정의된 애여야 함)
  - new 연산자 없이 호출하면 일반 함수로 호출됨

- new.target

  - 생성자 함수가 new 연산자 없이 호출되는 것을 막기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 발생할 수 잇다 ~ ← [new.target](http://new.target) 이라는게 있음
  - this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역변수와 같이 사용되며 메타 프로퍼티라고 부름
  - 함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로서 호출되었는지 확인할 수 있음

    - new 연산자와 함께 함수가 호출되면 함수 내부의 new.target은 함수 자신을 가리킴 (아닐때는 undefined) ← 이거 확인해갖고 재귀호출 통해 생성자 함수로서 호출할 수있다

    ```jsx
    function Circle(radius) {
    	if (!new.target) return new Circle(radius)
    	this.radius = radius;
    	this.getDiameter = function ~~
    }

    이러면 그냥 Circle(5) 해도 생성자 함수로서 호출됨
    ```

- new 연산자와 함께 생성자 함수에 의해 생성된 객체는 프로토타입에 의해 생성자 함수와 연결됨

## 18장 함수와 일급 객체

### 18.1 일급 객체

- 무명의 리터럴로 생성할 수 있음 (런타임에 생성 가능)
- 변수나 자료구조 등에 저장할 수 있음
- 함수의 매개변수에 전달할 수 있음
- 함수의 반환값으로 사용할 수 있음

```jsx
const increase = function (num) {}; // 1 무명의 리터럴
const auxs = { increase }; // 2 변수에 저장할 수 있음
function makeCounter(aux) {
  // 3 매개변수에 전달할 수 있음
  let num = 0;
  return function () {
    // 4 반환값으로 사용할 수 있음
    num = aux(num);
    return num;
  };
}

const increaser = makeCounter(auxs.increase); // 3
```

- 짜스의 함수는 위의 조건을 모두 만족함 ~!
- 함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미
  - 객체는 값이므로 함수는 값과 동일하게 취급할 수 있음
  - 함수는 값을 사용할 수 있는곳 (변수 할당문, 객체의 프로퍼티 값, 배열의 요소, 함수 호출의 인수, 함수 반환문 … 등등 어디서든지 리터럴로 정의할 수 있음)

### 18.2 함수 객체의 프로퍼티

- 함수는 객체다 - 함수도 프로퍼티를 가질 수 있음
- `console.dir(함수이름)` 통해서 모든 프로퍼티의 프로퍼티 어트리뷰트를 확인할 수 있음
  - `arguments, caller, length, name, prototype` ← 함수 객체의 데이터 어트리뷰트
  - `__proto__` ← 이거는 접근자 프로퍼티 (상속받음)
- arguments 프로퍼티
  - 값으로 arguments 객체를 가짐 - 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체 (함수 내부에서 지역변수처럼 사용)
  - ES3부터 표준에서 폐지 (함수 내부에서 arguments 사용해라 ~)
  - 함수를 정의할 때 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급
    - 암묵적으로 선언, undefined로 초기화, 인수 할당
    - 선언된 매개변수의 개수보다 인수를 적게 전달했을 경우 인수가 전달되지 않은 매개변수는 undefined
    - 더 많이 전달한 경우 초과된 인수는 무시 ,,, 하지만 arguments 객체의 프로퍼티에 있음
  - 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하다 ~
  - 유사 배열 객체 (객체이지만 … length 프로퍼티를 가진 객체로 for문으로 순회할 수 있음)
- caller 프로퍼티
  - 비표준 (빠큐)
  - 함수 자신을 호출한 함수를 가리킴
- length 프로퍼티
  - 함수를 정의할 때 선언한 매개변수의 개수를 가리킴
- name 프로퍼티
  - 함수 이름을 나타냄 (ES6)
  - 익명 함수 표현식의 경우 ES5/ES6에서 동작을 달리함
- **proto** 접근자 프로퍼티
  - 모든 객체는 Prototype이라는 내부 슬롯을 가지는데 … 객체지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킴
  - Prototype 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티
    (내부 슬롯은 직접 접근이 불가능하고 접근자를 통하여만 접근할 수 있음)
- prototype 프로퍼티
  - prototype 프로퍼티는 생성자 함수로 호출할 수 있는 함수 객체 - 즉 constructor 만이 소유하는 프로퍼티

## 19 프로토타입

- 짜스는 명령형, 함수형, 프로토타입 기반, 객체지향을 지원하는 멀티 패러다임 언어
- ES6에서 도입된 클래스가 기존의 프로토타입 기반 객체지향 모델을 폐지하고 새로운 모델을 제공하는 것은 아님 (문법적 설탕)

### 19.1 객체지향 프로그래밍

- 전통적인 절차지향적 관점에서 벗어나 여러개의 독립적 단위 - 객체의 집합으로 프로그램을 표현하는 패러다임임
- 실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도 - 실체는 속성(attribute)를 가지고 있음
- 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것을 추상화라고 함
- 속성을 통해 여러개의 값을 하나의 단위로 구성한 복합적인 자료구조 -객체
  - 상태 - 프로퍼티, 동작 - 메서드

### 19.2 상속과 프로토타입

- 상속: 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
- 짜스는 프로토타입을 기반으로 상속을 구현함

```jsx
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    return Math.pi * this.radius ** 2;
  };
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);

circle1.getArea === circle2.getArea; // false
```

- 위 코드를 보면 … 메서드는 똑같은디 중복생성된다 → 메모리 낭비임

```jsx
function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

const circle1 = new Circle(1);
const circle2 = new Circle(2);

circle1.getArea === circle2.getArea; // true
```

- 이러면 상속되지롱 ~

### 19.3 프로토타입 객체

- 프로토타입은 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용
- 프로토타입은 어떤 객체의 상위 역할을 하는 객체로서 다른 객체에 공유 프로퍼티 (메서드 포함) 를 제공함
- 프로토타입을 상속받은 자식 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 사용할 수 있음
- 모든 객체는 `[[Prototype]]` 이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조다

  - 여기 저장되는 프로토타입은 객체 생성 방식에 의해 결정됨

- 모든 객체는 하나의 프로토타입을 가짐
- 모든 프로토타입은 생성자 함수와 연결되어 있음
  ![요로케](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/47d9e891-c629-484d-a2e5-6e70db603f3e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-29_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.49.41.png)
  요로케
- `__proto__` 접근자 프로퍼티

  - 모든 객체는 접근자 프로퍼티를 통해 자신의 프로토타입 Prototype 내부 슬롯에 간접적으로 접근가능
  - `Get`, `Set` 을 통해 프로토타입 내부 슬롯의 값을 취득하거나 할당할 수 있음

- `__proto__` 는 상속을 통해 사용됨

  - `__proto__` 접근자는 객체가 직접 소유하는 프로퍼티가 아닌 Object.prototype의 프로퍼티임
  - 순환참조를 방지하기 위해서 (단방향으로 만들어야됨)

- `__proto__`의 직접 사용은 권장하지 않음

  - 대부분 브라우저가 지원하지만, 모든 객체가 사용할 수 있는 것은 아님 (직접 상속을 통해)
  - `getPrototypeOf` 메서드 사용 권장

- 함수 객체의 프로토타입 프로퍼티

  - prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입
  - 생성자 함수로서 호출할 수 없는 함수 (non-constructor) 인 화살표 함수 등은 프로토타입을 생성하지 않음
  - 일반 함수도 prototype 프로퍼티를 가지지만 … 의미가 없슴
  - 모든 객체가 가지고 있는 `__proto__` 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리키지만 .. 사용하는 주체가 다르다

    | 구분                     | 소유        | 값                | 사용 주체   | 사용 목적                                                          |
    | ------------------------ | ----------- | ----------------- | ----------- | ------------------------------------------------------------------ |
    | **proto**접근자 프로퍼티 | 모든 객체   | 프로토타입의 참조 | 모든 객체   | 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용            |
    | prototype 프로퍼티       | constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용 |

    ![스크린샷 2024-01-29 오전 2.04.07.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/0ee60047-09a0-4dcf-9a41-f21797378c8d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-29_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.04.07.png)

- 프로토타입의 constructor 프로퍼티와 생성자 함수

  - 모든 프로토타입은 constructor 프로퍼티를 가짐 - prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킴
  - 연결은 생성자 함수가 생성될 때 (함수 객체가 생성될 때) 이뤄짐
    ![스크린샷 2024-01-29 오전 2.05.48.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/c6f972de-5d76-41a6-a616-65bb95f3d8f8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-29_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.05.48.png)
    ```jsx
    Person 생성자 함수 -> me 객체 생성
    me 객체 -> 프로토타입의 constructor 프로퍼티를 통해 생성자 함수와 연결
    me 객체는 Person.prototype의 constructor 프로퍼티를 상속받아 사용
    ```

- 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

  - 명시적으로 new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하지 않는 방식

  ```jsx
  const obj = {};

  obj.constructor === Object; // true
  ```

  - 객체 리터럴로 생성한 객첸데 왜 Object 생성자 함수와 연결되어 잇슴 ?
    - ECMA 사양에서 Object 생성자 함수에 인수를 전달하지 않거나 undefined 또는 null을 인수로 전달하면서 호출하면 내부적으로는 추상 연산 `OrdinaryObjectCreate`를 호출하여 `Object.prototype`을 프로토타입으로 갖는 빈 객체를 생성
    - 객체 리터럴이 평가될 때 추샹 연산 `OrdinaryObjectCreate` 를 호출하여 빈 객체를 생성하고 프로퍼티를 추가
  - 그럼 함수는?

  ```jsx
  function foo() {}

  foo.constructor === Function; // true
  ```

  - 함수 객체를 생성한 것은 Function 생성자가 아니지만 생성자 함수는 Function 생성자 함수
  - 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 가짐

- **프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재함**

### 19.5 프로토타입의 생성 시점

- 생성자 함수가 생성되는 시점에 생성됨
- 생성자 함수는 - 사용자가 직접 정의한 생성자 함수와 빌트인으로 구분됨
- 사용자 정의 생성자 함수
  - 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 생성
  - 함수 선언문은 런타임 이전에 엔진에 의해 먼저 실행 - 프로토타입도 이때 같이 생성
- 프로토타입도 객체이고 모든 객체는 프로토타입을 가짐 (Object.prototype)
- 빌트인 생성자 함수 (Object, String, Number, Function … )
  - 프로토타입은 전역 객체가 생성되는 시점에 생성됨 (window, global)
    `전역 객체는 빌트인 객체들과 환경에 따른 호스트 객체, 전역 변수, 전역 함수를 프로퍼티로 가짐`

### 19.6 객체 생성 방식과 프로토타입의 결정

- 추상 연산 `OrdinaryObjectCreate` 에 의해 생성됨
- 객체 리터럴
  - 엔진이 리터럴 평가 → 객체 생성
    `(OrdinaryObjectCreate 호출), Object,prototype 생성`
- Object 생성자 함수
  - 생성자 함수를 인수 없이 호출하면 빈 객체가 생성
    `(OrdinaryObjectCreate 호출) , Object,prototype 생성`
- 생성자 함수에 의해 생성된 객체
  - new 연산자와 함께 생성자 호출 → 인스턴스 생성
    `(OrdinaryObjectCreate 호출) , 생성자 함수의 prototype 프로퍼티에 바인딩 객체`
    ![스크린샷 2024-01-29 오전 11.13.40.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/8b09cb27-e088-45aa-a868-3cb6406426ab/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-29_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.13.40.png)
  - 이런 방법으로 생성하면 Object.prototype의 빌트인 갖고 있지 않음 (constructor 뿐임)
  - Person.prototype에 프로퍼티를 추가하여 자식 객체가 상속받도록 구현 가능

### 19.7 프로토타입 체인

- 위의 me 객체도 Object.prototype의 빌트인 메서드인 hasOwnProperty 등을 호출할 수 있음
  Object.prototype 또한 상속받았다는 것 의미
- 프로토타입 체인 - 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 부모 역할의 프로퍼티를 순차적으로 검색
- Object.prototype은 프로토타입 체인의 종점 → 얘의 프로토타입은 null
  `종점까지 가서 프로퍼티 검색할 수 없는 경우 undefined 반환 (에러 ㄴㄴ)`

### 19.8 오버라이딩과 프로퍼티 섀도잉

```jsx
const Person = (function () {
	function Person(name) {
		this.name = name
	}

	Person.prototype.sayHello = function () {
		console.log(this.name)
	}

	return Person
}())

생성자 함수로 객체를 생성한 다음 -> 메서드 추가
```

![스크린샷 2024-01-29 오전 11.26.59.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/a7bf3dac-661a-4ef1-a403-4525363a3946/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-29_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.26.59.png)

- 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 체인을 따라 프로토타입 프로퍼티를 검색하여 덮어 쓰는것이 아니라 인스턴스 프로퍼티로 추가함
- 인스턴스 메서드 sayHello는 프로토타입 메서드 sayHello를 오버라이딩 (프로토타입 메서드는 가려짐)
- 하위 객체를 통한 프로퍼티의 변경 또는 삭제는 불가 - 직접 접근해야댐

### 19.9 프로토타입의 교체

- 프로토타입은 임의의 다른 객체로 변경가능 - 부모 객체인 프로토타입을 동적으로 변경할 수 있음
  ![스크린샷 2024-01-29 오전 11.32.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/60b7f45c-9a2e-4f16-be5c-ff00d4060cc3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-29_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.32.57.png)
- Person 생생자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체 (constructor 프로퍼티가 없음)
  - constructor 프로퍼티와 생성자 함수간의 연결이 파괴됨
  - constructor 프로퍼티를 추가해서 프로토타입의 프로퍼티 되살릴 수 있음
  - 다른 임의의 객체 바인딩 → 미래에 생성할 인스턴스의 프로토타입 교체하는 것
- `__proto__` 접근자 프로퍼티를 통해 접근할 수 있음 (교체도 가능)
  - 다른 임의의 객체 바인딩 → 이미 생성된 객체의 프로토타입 교체하는 것
    ![스크린샷 2024-01-29 오전 11.38.12.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3eeb4e3-6b78-46d1-bac6-edf69767a4e2/bb6fce21-0447-43ab-8af3-65c51d53dfdc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-01-29_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.38.12.png)
  - 직접 상속이나 클래스 써라 ~

### 19.10 instanceof 연산자

- `객체 instanceof 생성자 함수`
- 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true
- 생성자 함수의 prototype에 바인딩 된 객체가 프로토타입 체인 상에 존재하는지 확인
- 생성자 함수에 의해 프로토타입이 교체되어도 연결은 파괴 ㄴㄴ → 영향 안됨

### 19.11 직접 상속

- Object.create 메서드 사용한 직접 상속
- 객체 내부에서 \***\*proto** \*\*에 의한 직접 상속

### 19.12 정적 프로퍼티/메서드

- 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드
- 인스턴스/프로토타입 내에서 this를 사용하지 않는다면 그 메서드는 정적메서드로 변경할 수 있음
  - 인스턴스가 호출한 인스턴스/프로토타입 내에서 this는 인스턴스를 가리킴

### 19.13 프로퍼티 존재 확인

- in 연산자
  `key in object`
  - 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인
- Object.prototype.hasOwnProprty

### 19.14 프로퍼티 열거

- for … in
  `for (변수선언문 in 객체) { }`
  - 상속받은 프로토타입의 프로퍼티까지 열거
  - enumerable === false인 애들 열거 불가능
- Object.keys/values/entries
  - 객체 자신의 프로퍼티 열거
